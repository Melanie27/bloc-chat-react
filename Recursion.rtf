{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww16020\viewh11940\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Recursion\
\
1. Define and Compare recession and iteration\
Recursion describes a function that calls itself. Recursive solutions require base case conditions\
to stop them from going on infinitely. Check the base cases first and if none of those are met\
move on to execute the recursive case.\
\
Iteration is when you solve a problem using a loop to repeat a process. Recursive solutions\
tend to run more slowly than iterative solutions. They are also more subject to system\
limitations. But, iterative solutions can be harder to implement.\
\
2. Name 5 algorithms that are commonly implemented by recursion\
Factorial algorithm, Fibonacci sequence, Binary Search, Reversing a String, Greatest Common Divisor\
\
3. When should you use recursion and when should you avoid recursion?\
You should use recursion when an algorithm can be defined as a combination of sub-results that starts with known cases. Even when the recursive solution seems like the best solution you have to examine the cost of the repeated calculations and if that cost causes a performance problem that could be obviated by an iterative solution.\
\
4. Compare the recursive solutions and iterative solutions to the three algorithms from the checkpoint (Factorial, Maximum and Fibonacci).\
Iterative sets the variable (or variables) and the for loop is the meat of the solution. The iterative solutions return a list, where each element is evaluated through the loop until the loop runs out of elements. The factorial solutions all start with one or more bases cases. Then they run a function that changes the argument being passed to the function and forces another function call, until we hit the base case.\
\
5. \
var test = [ [1,4,9], [34, 6, [1,3,4] ], [ 9, 7, 89] ];\
class Counter \{\
	constructor()\{\
		this.count = 0;\
	\}\
	countItems(arr)\{\
		while (arr.length > 0) \{\
			var item = arr.pop();\
			if(Array.isArray(item)) \{\
				this.countItems(item);\
			\} else \{\
				this.count++;\
			\}\
		\}\
	\}\
\}\
\
var counter = new Counter();\
counter.countItems(test);\
console.log(counter.count);\
\
6.\
\
function isPalindrome(testString) \{\
	let length = testString.length;\
	if(length <= 1) \{\
		return true;\
	\}\
	if(testString.charAt(0) === testString.charAt(length - 1)) \{\
		return isPalindrome(testString.slice(1, length - 1));\
	\}\
	return false;\
\}\
	console.log(isPalindrome('racecar'));\
	console.log(isPalindrome('cat'));\
\
\
7.\
\
var houses = [\{house:'house1', hasCat:false\}, \{house : 'house2',  hasCat:false\}, \{house : 'house3',  hasCat:false\}, \{house : 'house4',  hasCat:true\}, \{house : 'house5',  hasCat:false\}, \{house : 'house6',  hasCat:false\}, ];\
\
function checkForCat(houses) \{\
  \
  if (houses.length <1 || houses === undefined ) \{\
    return false;\
  \}\
  \
  var firstHouse = houses.shift();\
  \
   if(firstHouse.hasCat === true) \{\
     return true;\
   \} else \{\
     \
     console.log(firstHouse);\
     return checkForCat(houses);\
   \}\
  \
\}\
\
console.log(checkForCat(houses));}